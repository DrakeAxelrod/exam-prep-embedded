# Question 1 multiple choice (Warm Up) - 10 Points

## Question 1.1

> For the expression (a || c) && (b || !c), the test suite
> (a, b, c) = {(T, F, T), (F, F, T), (F, T, T), (T, F, F)} provides:

a. MC/DC Coverage
_b. Decision Coverage_
_c. Basic Condition Coverage_
d. Compound Condition Coverage

              T            F
test #1 -> (T || T) && (F || !T) -> F
              T            F
test #2 -> (F || T) && (F || !T) -> F
              T            T
test #3 -> (F || T) && (T || !T) -> T
              T            T
test #4 -> (T || F) && (F || !F) -> T

## Question 1.2

> Verifying that a system meets its specification is sufficient to determine if the users’
> needs have been met.

a. True
_b. False_

## Question 1.3

> All DU paths coverage requires that all paths between each definition and each of its
> usages be covered by at least one test case.

a. True
_b. False_

## Question 1.4

> A banking website that displays an error message and stops all normal operations when
> a database connection cannot be established is which of the following:

a. Correct with respect to its specification.
b. Safe to operate.
_c. Robust in the presence of exceptional conditions._
_d. Considered to have passed verification._

## Question 1.5

> In random ascent, we take the first neighbouring solution to show any improvement over
> the current solution as the new solution.

_a. True_
b. False

## Question 1.6

> A mutant is considered valid, but not useful, if it compiles, but the majority of tests fail.

_a. True_
b. False

## Question 1.7

You are buying a server for your online business and are concerned with the recovery
time after a failure. What reliability measure would be of most interest to you?

_a. Availability_
b. Probability of failure on demand
c. Mean time between failures
_d. Rate of fault occurrence_

> How to calculate mean time to repair
> You can calculate MTTR by adding up the total time spent on repairs during any given period and then dividing that time by the number of repairs.
> So, let’s say we’re looking at repairs over the course of a week. In that time, there were 10 outages and systems were actively being repaired for four hours. Four hours is 240 minutes. 240 divided by 10 is 24. Which means the mean time to repair in this case would be 24 minutes.

> How to calculate mean time to recovery
> Mean time to recovery is calculated by adding up all the downtime in a specific period and dividing it by the number of incidents. So, let’s say our systems were down for 30 minutes in two separate incidents in a 24-hour period. 30 divided by two is 15, so our MTTR is 15 minutes.

- Availability: (uptime) / (total time observed)
- POFOD: (failures/ requests over period)
- ROCOF: (failures / total time observed)
- MTBF: Average time between observed failures.
- MTTR: Average time to recover from failure.

# Question 2 (Quality Scenarios) - 10 Points

> Consider the cockpit display system for an aircraft. This system updates a display that offers the
> pilot important information on the status of the aircraft, including the fuel level, altitude, auto-pilot
> status, and any warnings about equipment failure or required aircraft maintenance.
> Identify one performance and one availability requirement that you think would be necessary for
> this system and develop a quality scenario to verify each of them.
> Write your own scenarios - do NOT reuse or lightly rewrite those from the slides or assignments.

- Performance Requirement
  Under normal load, the system shall updated the current fuel level and display it on the console console every 10ms

| Stage                    | Performance                                                                                                                                                                              |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview                 | Performing a standard system checking during a flight in which the airplane is cruzing at a safe allitude from gothenburg (sweden) with a destination set to los angeles (United States) |
| External Stimulus        | The system detects a minor fuel leakage thus excellerating the consumption of the flights fuel                                                                                           |
| System State             | Standard Operation (in this case international flight)                                                                                                                                   |
| System Environment       | long flight, international, minor hardware defect, fuel is leaking causing higher consumption of resource                                                                                |
| Required System Response | The system accurate displays the descrepency in fuel usage based on the the leakage so that the pilots can make an informed decision regard how to proc with the flight                  |
| Response measure         | the display does update with changes in fuel status within the specified 10ms                                                                                                            |

- Availability Requirement
  The system should maintain an availabilty of six nines (0.999999 - 31.56 seconds per year (86.40 milliseconds per day))

| Stage                    | Availability                                                                                                                                              |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Overview                 | During a national flight between Colorado and Denver a storm occurs causing turbulance resulting in cabin essential equipment to experince a power outage |
| External Stimulus        | unexpected storm during flight                                                                                                                            |
| System State             | stand normal operation                                                                                                                                    |
| System Environment       | national flight, loss of connect to essential equipment due to turbulance                                                                                 |
| Required System Response | system reallocates power to backup systems and switches to use the backup systems                                                                         |
| Response measure         | the MTTR should be less then 40ms                                                                                                                         |

O.S.S E.R.R -> Overview, Stimulus, State, Environment, Required System Response, Response Measure

# Question 3 (Testing Concepts) - 9 Points

> Choose one stage of testing (unit testing, system testing, GUI testing, exploratory testing, or
> acceptance testing). Explain in your own words what that stage is, how systems are tested in
> that stage, how it differs from the other listed stages of testing, and the types of faults that are
> most likely to be exposed by that stage (that would be missed during the other stages).

Exploratory testing

Exploratory testing is a time based form of testing in which you attempt to test your system on the fly by simply exploring the application these are called 'tours', which are the guidelines/objectives to explore a system. An individual usually has a goal/objective which he wishes to complete during the allocated time. It is a form of structured testing in which you allocate time and you have the aforementioned guidelines such as a list of items that you want to see whether or not conform to specification. It can be the case that since you do not have requirements available to you something that is a functionality might be respresented as a defect. This form of testing is not automated and therefore takes more time then other tests that are automated. 

This form of testing differs from for example unit testing in which small tests are written for functions, and test suites for classes. Uniting testing while require time investment to write the actual tests is then mostly automated from that point forward. Unit testing is often used in CI/CD for example on a branch / push or merge, or a product deployment cycle. Whereas something like exploratory testing would be done on a less frequent basis and as mentioned would be automated. Unit testing looks at classes in a vacuum only concerned with whether its internal behavoir is correct.

System testing Is concerned with the way in which the system interacts at a whole do the different classes play nice?
is the system operating as expected internall when different portions communicate with eachother. Does the GUI and backend correspond to eachother. essentially unit testing tests portions of a system. System testing tests the functionaly of how those subsystems work together.

the general recommendation is to split the testing into 70% unit, 20% system, 10% GUI (exploratory)

# Question 4 (System Testing) - 12 Points

> Consider a feature that books a meeting in a designated room at a specified date, with a
> specified start and end time.

```
String bookMeeting (String roomID, String date, String startTime, String endTime)
```
This function returns a string with one of the following messages:
- "Booked" if the meeting was booked successfully.
- "Busy" if the room already has a meeting booked that overlaps with the requested timeframe.
- "Malformed Input" if any input items are malformed.
- "Illegal Time" if there are any errors related to the date, start time, or end time.

> A well-formed date string is of the format "YYYY-MM-DD" (e.g., "2021-12-23").
> A well-formed time string is of the format "HH:MM" (e.g., "14:45").

> If you wish to make any additional assumptions about the functionality of this feature, state them in your answer.


> Perform category-partition testing for this feature.
1. For each parameter, identify testing choices (controllable items that can be varied when testing)
2. Identify representative input values (types of input choices) for each choice.
3. Apply constraints (IF, ERROR, SINGLE) where they make sense.

> You do not need to create test specifications or concrete test cases.

> Hint: Do not forget about environmental factors that can influence system output.
> For invalid input, do not just write "invalid" - be specific.


1)
> inputs include

- String roomID
- String date
- String startTime
- String endTime

2)
> assuming that rooms are identified by a string representing the number for example room1, room2, room3, etc...
> we assume you cant book a room in the past
> we assume that you can only book so far in the future
> we assume that room idenfiers have a format
> we assume that the location is not open 24hrs therefore it has operational hours and the time for the booking must fall within
Choice String roomID:
 - malformed (integer, double, float, object, incorrect format)
 - not a room in database
 - valid (string that signifies a room indentifier that is within the database)
Choice String date:
 - malformed (not in specified format "YYYY-MM-DD" (e.g., "2021-12-23"))
 - date is in the passed
 - date is beyond acceptable scope in the future
 - valid
Choice String startTime:
 - malformed (not in specified format "HH:MM" (e.g., "14:45"))
 - time is not in the passed
 - time is within operational hours
 - time after endTime
 - valid
Choice String endTime:
 - malformed (not in specified format "HH:MM" (e.g., "14:45"))
 - time is after the startTime
 - time is within operational hours
 - time before startTime
 - valid

3)
Choice String roomID:
 - malformed (integer, double, float, object, incorrect format, empty)          *(ERROR)*
 - not a room in database                                                       *(ERROR)*
 - valid (string that signifies a room indentifier that is within the database) *(IF)*
Choice String date:
 - malformed (not in specified format "YYYY-MM-DD" (e.g., "2021-12-23"))        *(IF)*
 - date is in the passed                                                        *(ERROR)*
 - date is beyond acceptable scope in the future                                *(IF)*
 - valid
Choice String startTime:
 - malformed (not in specified format "HH:MM" (e.g., "14:45"))                  *(IF)*
 - time is not in the passed                                                    *(IF)*
 - time is within operational hours                                             *(IF)*
 - time after endTime                                                           *(ERROR)*
 - valid
Choice String endTime:
 - malformed (not in specified format "HH:MM" (e.g., "14:45"))                  *(IF)*
 - time is after the startTime                                                  *(IF)*
 - time is within operational hours                                             *(IF)*
 - time before startTime                                                        *(ERROR)*
 - valid

# Question 5 (Exploratory Testing) - 8 Points

> Exploratory testing typically is guided by “tours”. Each tour describes a different way of thinking
> about the system-under-test and prescribes how the tester should act when they explore the
> functionality of the system.
1. Describe one of the tours that we discussed in class OTHER than the supermodel tour.
2. Consider a web-based inventory management system, where a user can (among other functionalities) check inventory status for a single item or all items, update the number of units of a particular item in the inventory, add new item types, and display and edit metadata about each item. Describe three actions you might take during exploratory testing of this system, based on the tour you described above. (You may make any assumptions you would like about the functionality of this system - as long as you state those exceptions clearly)

Saboteur Tour:
> Descriptiong
this tour involves trying to actively break different aspects of the application.
for example attempting to use malformed inputs, strange orders of operation. Manipulation
of resources. give the application corrupted data, mess with the netowrk connectivity, restrict the applications resources. Essentially break it.

> Actions
check inventory status for a single item or all items and display and edit metadata about each item
- Check to see whether the application properly sanitize input fields to account for xss.
- Send malformed http requests with for example corrupted headers, or headers or a body that have potentially evaluatable script
- edit an inventory to have negative values, try to put script inside inventory values
- try to put script literally anywhere you can think of it.
- getting a lil bit more into pentesting territory but you can could try get a reverse shell if you find somewhere that you can execute code.
- you can see if the website exposes unnecessary information in the html, such as comments modules used, frameworks etc as all can serve as potential vulnerabilities



# Question 6 (Unit Testing) - 8 Points
> Consider a Java method for sorting an array:
> int[] quickSort (int[] unsorted, int length);
> Write JUnit-formatted test cases to do the following:
1. Check whether the unordered array given to the method is returned in the expected
order.
2. Check whether an index out of bounds exception is thrown when the inputted length is
either negative or greater than the length of the array.

```java
void testArraySorted()
{
  int A[6] = { 5, 1, 3, 0, 2, 4 };
  A = quickSort(A, len);
  assertEqual({ 0, 1, 2, 3, 4, 5 }, A); 
  // not sure if its the case that you can
  // check for equality with arrays in java this way
  // if you cannot one way of doing this is with a for loop and a boolean 
  // and a if condition that flips boolean to false 
  // if a value is not what is it supposed to be 
  // then assert on the bool value.
}
void testIndexOutOfBoundThrown()
{
  int A[1] = { 0 };
  assertThrows(IndexOutOfBound.class, () -> {
    A[2] = 666;
  })
}
```

# Question 7 (Structural Testing) - 16 Points
> For the following method:
```java
  1. public static String collapseSpaces(String argStr){
  2.  char last = argStr.charAt(0);
  3.  StringBuffer argBuf = new StringBuffer();
  4.  for(int cldx=0; cldx < argStr.length(); cldx++) {
  5.    char ch = argStr.charAt(cldx);
  6.    if(ch != ‘ ‘ || last != ‘ ‘) {
  7.      argBuf.append(ch);
  8.      last = ch;
  9.      }
  10.   }
  11.   return argBuf.toString();
  12. }
```

1. Draw the control-flow graph for this method. You may refer to line numbers instead of writing the full code.

2. Develop test input that will provide statement coverage. For each test, list the statements covered.

3. Develop test input that will provide branch coverage. For each test, list the branches covered (use the line number and T or F, i.e., “3-T” for the true branch of line 3).

4. Develop test input that will provide basic condition coverage. For each test, list the conditions covered.


1)

```
             [ 1 ]
               ↓
             [ 2 ]
               ↓
             [ 3 ]
          F    ↓      T
      ------ < 4 > -------
     ↓                   ↓
  [ 11 ]               [ 5 ]
                   F     ↓      T
                ------ < 6 > -------
                ↓                   ↓
              [ 11 ]              [ 7 ]
                                    ↓
                                  [ 8 ]
                                    ↓
                                  [ 4 ]
```

2)

'this' -> 1,2,3,4,5,6,7,8,4,5,6,7,8,4,5,6,7,8,4,5,6,7,8,4,11

3)

'this' -> '4-T', '6-T', '6-F'
'' -> '4-F'

4)

'this' -> '4-T', '6-T', '6-T', '6-T', '6-T', '4-F'
'a ' -> '4-T', '6-F', '6-T', '4-F'

# Question 8 (Data Flow Testing) - 12 Points
>This method computes the longest common sequence of characters between two strings:
```java
1. public String findLongestCommonSequence(String s1, String s2) {            // def
2.    String result = "";                                                     // def
3.    for (int length = s1.length(); length > 0; length--) {                  // def, use
4.        int startIndex = 0;                                                 // def
5.        while (startIndex + length <= s1.length()) {                        // use 
6.            String current = s1.substring(startIndex, startIndex + length); // def, use
7.            if (s2.contains(current)) {                                     // use
8.                result = current;                                           // def, use 
9.                break;
10.            }
11.            startIndex++;                                                  // def, use
12.       }
13.       if (result.length() != 0) {                                         // use
14.           break;
15.       }
16.   }
17.   return result;                                                          // use
18. }
```
1. Identify the def-use pairs for all variables.
2. Provide a test suite that achieves all def-use pairs coverage.

s1:
(1, 3) (1, 5) (1, 6)

s2:
(1, 7)

result:
(2, 8) (2, 13) (2, 17) (8, 13) (8, 17)

length:
(3, 5) (3, 6) (3, 13)

startIndex:
(4, 5) (4, 6) (4, 11) (11, 5) (11, 6)

current:
(6, 7) (6, 8)


s1 = "ok", s2 = "okay"

s1 = "yes", s2 = "no this doesnt have the word"

# Question 9 (Mutation Testing) - 15 Points
> Consider the following function:

```java
1. int max (int a[], int n) {
2.    int m = n - 1;
3.    while(n > 0) {
4.      n = n - 1;
5.      if (a[n] > a[m]) {
6.        m = n;
7.      }
8.    }
9.    return m;
10. }
```

Answer the following three questions for each of the following mutation operators:
- Relational operator replacement (ror)
- Arithmetic operator replacement (aor)
- Constant for constant replacement (crp)

1. Identify all lines that can be mutated using that operator.
2. Choose one line that can be mutated by that operator and create one non-equivalent mutant.
3. For that mutant, provide test input that would detect the mutant. Show how the output(return value of the method) differs from that of the original program.

1)
ror) 2,3,4,5,6
aor) 2,4
crp) 2, 3, 4

2)
ror) 2 swap the > to <
aor) 4 swap the - to +
crp) 4 change 1 to 10

3)
ror) n=-1, a = { 0, 1, 2 } -> throws IndexOutOfBounds
aor) n=2,  a = { 0, 1, 2 } -> throws IndexOutOfBounds
crp) n2,   a = { 0, 1, 2 } -> throws IndexOutOfBounds




